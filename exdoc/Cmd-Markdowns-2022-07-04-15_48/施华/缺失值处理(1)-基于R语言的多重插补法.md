# 缺失值处理(1)-基于R语言的多重插补法

标签（空格分隔）： 施华

---


对于缺失值的处理，一般分为两步，第一，考虑缺失值产生的原因，不同的原因对应着不同的处理方法。一般情况下，可以分为随机缺失和非随机缺失，对于完全随机缺失，直接剔除一般不会带来偏误，而对于非完全随机缺失，由于缺失值出现的位置可能和其他变量有关联，带来的后果则相对复杂得多。本文主要基于R语言mice包来做缺失值的处理。

### 1.缺失值初步分析
首先我们要分析缺失值的大致情况，再根据情况决定我们采用删除法还是填补法，比较快捷方便的评价标准是缺失率，在R中可以直接用mice包中的md.pattern函数查看数据缺失情况，也可以自己编写函数计算缺失率。还可以用VIM包做可视化观察。
summary函数查看
```R
library(mice)
md.pattern(data) # 输出结果中会报告缺失值的数量
```
编写函数查看
```R
na_rate <- function(data)
{
r = sum(is.na(data))/length(data)
return(r)
}
```
用VIM包可视化查看
```R
library(VIM)
aggr(sleep,prop=F,numbers=T)
# x 表示a vector, matrix or data.frame
# 当prop=T时坐标轴上显示缺失值个数，当prop=F时坐标轴上显示缺失值比例
# numbers=T不删除数值型标签，unmbers=F删除数值型标签
# VIM包中还有其他可视化缺失值的函数，matrixplot和marginplot比较常用
```
在实际应用中，缺失值的比率一般在5%为最佳，超过20%的考虑删除变量，在5%到20%之间的考虑删除缺失值所对应的行。


### 2.删除法
- 直接删除有缺失值的样本
- 删除存在大面积缺失值的变量。
```R
data_na_omit <- na.omit(data) # 删除缺失值的行
data_na_complete <- complete.cases(data) # 删除变量可以直接不选用,选用完整的样本值
```


### 3.利用mice包做多重插补
R语言的mice包主要采用的缺失值填补方法为多重插补，对应的流程如下:
**缺失数据集——每个数据集进行插补建模（glm、lm模型）——将这些模型整合到一起（pool）——评价插补模型优劣（模型系数的t统计量）——输出完整数据集（compute）**
函数mice()首先从一个包含缺失数据的数据框开始，然后返回一个包含多个（默认为5个）完整数据集的对象。每个完整数据集都是通过对原始数据框中的缺失数据进行插补而生成的。由于插补有随机的成分，因此每个完整数据集都略有不同。然后,with()函数可依次对每个完整数据集应用统计模型（如线性模型或广义线性模型）,最后,pool()函数将这些单独的分析结果整合为一组结果。最终模型的标准误和p值都将准确地反映出由于缺失值和多重插补而产生的不确定性。

**(1)** 用mice函数生成缺失值填补矩阵
```R
library(mice) # 载入mice包
tmpData = mice(data,m=5,maxit=50,meth='pmm')
# mice函数的参数注释
# data，需要填充的数据集
# m，多重填补法的填补矩阵数。默认为5
# maxit，迭代次数，默认50次
# meth是指定拟合方法
meth[c("x1")]="" # 不x1变量进行插值拟合
meth[c("x2")]="norm" 
meth[c("x3")]="logreg"
meth[c("x4")]="polyreg"
# 对不同变量用不同的方法拟合
```
**(2)** 用with函数对每一个完整数据集应用统计模型,建模方法可以选择。输出的是每一个插补完整数据集下的统计模型估计参数。
```R
fit<-with(imp, lm(x1~`)# 函数依次对完整的数据集进行统计建模,这里选用的建模方法为线性回归
# with对象。插补模型可以多样化，比如lm，glm都是可以直接应用进去，详情可见《R语言实战》第十五章
```
**(3)** 用pool函数查看在同一种建模方法下，产生的多个插补完整数据集的优劣。从with结果中选择一个最接近pool结果的一个插补完整数据集，当然前提是pool给出的结果都是统计显著的，不然要换建模方法。
```R
pooled <- pool(fit)
summary(pooled) 
# pool对象。summary之后，会出现lm模型系数，可以如果出现系数不显著，那么则需要考虑换插补模型；
```
**(4)** 用complete函数给出插补结果
```R
result = complete(tmpData,action=3) # action=3表示选择第三个插补数据集作为结果，为何选择第三个是从with-pool步骤看出来的。
```
**在使用Mice包的过程中会出现以下的疑惑：**
已经有mice函数补齐了缺失值，可以直接用compete直接调出，为啥还要用with，pool？mice函数中默认插补5个数据集，那么哪个数据集最好，值得选出？
**with-pool的作用是用来选择数据集的。**
with函数中有5个插补数据集的回归模型～数据集T检验～某数据集是否合格；pool函数把5个回归模型汇总～数据集F检验～整个方法是否合格。
**(5)** 批量导出插补完整数据集
```R
output_data = result # result为上文中最终得出的插补完整数据集
write.csv(output_data,'output_data.csv') # 批量导出CSV文件的数据
``` 






